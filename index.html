<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0" />
<title>Flappy Bird — Premium UI (Multiplayer)</title>
<style>
:root{
  --glass: rgba(255,255,255,0.08);
  --glass-strong: rgba(255,255,255,0.12);
  --accent: linear-gradient(135deg,#ffd166,#ff7b7b);
  --shadow: 0 10px 30px rgba(0,0,0,0.35);
}
*{box-sizing:border-box;margin:0;padding:0;font-family:Inter,system-ui,Arial,sans-serif}
html,body{height:100%;background:linear-gradient(180deg,#0f172a 0%, #05668d 60%);overflow:hidden}
#stage{position:relative;width:100%;height:100%;display:flex;align-items:center;justify-content:center;}
canvas{border-radius:18px;box-shadow:var(--shadow);background: linear-gradient(180deg,#70c5ce 0%, #5fbad0 100%);display:block;touch-action:none;}
#titleBar{position:fixed;top:20px;left:50%;transform:translateX(-50%);z-index:9999;display:flex;gap:12px;align-items:center;pointer-events:auto;}
.btn{background: var(--accent);color: #111;padding:10px 20px;border-radius:12px;cursor:pointer;backdrop-filter: blur(6px);box-shadow: 0 10px 26px rgba(255,140,120,0.18);font-weight:600;border:none;transition: transform 0.1s, box-shadow 0.1s;}
.btn:hover:not(:disabled){transform: translateY(-2px);box-shadow: 0 12px 28px rgba(255,140,120,0.25);}
.btn:active:not(:disabled){transform: translateY(0);box-shadow: 0 10px 26px rgba(255,140,120,0.18);}
.btn:disabled{opacity: 0.6; cursor: not-allowed; filter: grayscale(100%);}

.overlay{position: absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:9998;pointer-events:auto;}
#startUI, #gameOverUI{width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:18px;backdrop-filter: blur(10px);background: linear-gradient(180deg, rgba(0,0,0,0.35), rgba(0,0,0,0.45));color:white;text-align:center;}
#titleLarge{font-size:72px;font-weight:900;letter-spacing:6px;text-shadow: 0 8px 30px rgba(0,0,0,0.6), 0 0 30px rgba(255,255,255,0.06);}
#subtitle{font-size:18px;opacity:0.9;}
#homeHighScore{font-size:18px;opacity:0.85;}
#scoreLabel{position:absolute;top:110px;left:50%;transform:translateX(-50%);color:white;z-index:9998;font-weight:700;font-size:20px;text-shadow:0 6px 18px rgba(0,0,0,0.45);}
#multiplayerStatus{position:fixed;top:20px;right:20px;color:white;font-weight:700;z-index:10000}

/* New Debug Panel Style */
#debugPanel {
    position: fixed;
    top: 60px;
    right: 20px;
    background: rgba(0, 0, 0, 0.7);
    color: #ffcc00;
    padding: 8px;
    border-radius: 6px;
    font-size: 12px;
    z-index: 10000;
    display: none; /* Hidden by default, shown when MP connected */
    font-family: monospace;
}
.score-box {
    margin-top: 15px;
    padding: 20px;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 12px;
    width: 90%;
    max-width: 320px;
    text-align: left;
    border: 1px solid rgba(255, 255, 255, 0.1);
}
.score-box h3 {
    text-align: center;
    font-size: 20px;
    margin-bottom: 10px;
    text-transform: uppercase;
}
.score-line {
    display: flex;
    justify-content: space-between;
    padding: 4px 0;
    font-size: 16px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}
.score-line:last-child { border-bottom: none; }
#winnerMessage {
    font-size: 28px;
    font-weight: 900;
    margin: 15px 0 20px 0;
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    color: #ffcc00; /* Gold color for winner */
}
#waitingMessage {
    font-size: 20px;
    font-weight: 500;
    color: #fff;
    margin-top: 20px;
}
#roomCodeInput {
    padding: 10px;
    border-radius: 8px;
    border: none;
    width: 200px;
    color: #111;
    font-weight: 500;
    text-align: center;
}
@media (max-width:480px){
  #titleLarge{font-size:44px}
  .btn{padding:8px 10px}
}
</style>
</head>
<body>
<div id="stage">
  <div id="titleBar"></div>

  <div id="scoreLabel">Score: <span id="scoreNum">0</span> | Bird Hit Points: <span id="enemyScore">0</span></div>
  <div id="multiplayerStatus" style="display:none">Multiplayer: <span id="mpStatus">disconnected</span></div>
  
  <div id="debugPanel" style="display:none;">
    MP Debug Status:<br>
    GO: <span id="debugGO">false</span><br>
    Pending: <span id="debugPending">false</span><br>
    Opp Alive: <span id="debugOppAlive">false</span><br>
    Opp Connected: <span id="debugOppConnected">false</span>
  </div>

  <canvas id="gameCanvas" width="400" height="600" aria-label="Flappy bird game"></canvas>

  <div id="startUI" class="overlay" style="display:flex;">
    <div style="display:flex;flex-direction:column;align-items:center;gap:20px;">
      <div id="titleLarge">FLAPPY BIRD</div>
      <div id="subtitle">Premium UI • Competitive Multiplayer</div>
      <div id="homeHighScore">High Score: <span id="homeHighScoreNum">0</span></div>
      
      <div id="mainMenuButtons" style="display:flex;flex-direction:column;align-items:center;gap:10px;">
        <div style="display:flex;gap:12px;">
            <button id="startMainBtn" class="btn">Start Local Game</button>
        </div>
        <div style="display:flex;gap:10px;margin-top:10px;">
            <button id="createRoomBtn" class="btn">Create Room</button>
            <button id="joinRoomBtn" class="btn">Join Room</button>
        </div>
      </div>
      
      <div id="joinRoomContainer" style="display:none; flex-direction:column; gap:10px; align-items:center; margin-top:10px; padding: 15px; background: var(--glass-strong); border-radius: 12px;">
        <input type="text" id="roomCodeInput" placeholder="Enter Room Code (e.g., A1B2)" maxlength="4" style="text-transform: uppercase;">
        <button id="submitJoinBtn" class="btn" style="background: linear-gradient(135deg,#00b4d8,#0077b6); color:white; padding: 10px 20px;">Join Game</button>
        <button id="cancelJoinBtn" class="btn" style="background: #6c757d; color:white; padding: 8px 15px;">Cancel</button>
      </div>

      <div id="roomCodeDisplay" style="margin-top:8px;font-weight:700;opacity:0.95"></div>
    </div>
  </div>

  <div id="gameOverUI" class="overlay" style="display:none;">
    <div style="text-align:center; display:flex; flex-direction:column; align-items:center; padding: 20px;">
      <div style="font-size:40px;font-weight:900">Game Over</div>
      <div id="winnerMessage" style="display:none;"></div>
      <div id="waitingMessage" style="display:none;">Waiting for opponent to finish...</div>

      <div id="multiplayerResultContainer" style="display:flex; gap: 20px; justify-content:center; flex-wrap: wrap;">
        <div class="score-box">
          <h3>Your Results</h3>
          <div class="score-line"><span>Pipe Score:</span> <span id="finalScore">0</span></div>
          <div class="score-line"><span>High Score:</span> <span id="finalHigh">0</span></div>
          <div class="score-line"><span>Hit Points:</span> <span id="finalEnemyScore">0</span></div>
        </div>

        <div id="opponentResultBox" class="score-box" style="display:none;">
          <h3>Opponent Results</h3>
          <div class="score-line"><span>Pipe Score:</span> <span id="opponentFinalScore">0</span></div>
          <div class="score-line"><span>Hit Points:</span> <span id="opponentFinalEnemyScore">0</span></div>
        </div>
      </div>

      <div style="margin-top:25px;display:flex;gap:10px;justify-content:center">
        <button id="playAgainBtn" class="btn">Play Again</button>
        <button id="goHomeBtn" class="btn">Main Menu</button>
      </div>
    </div>
  </div>
</div>

<script>
const internalW = 400, internalH = 600;
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

const startUI = document.getElementById('startUI'), gameOverUI = document.getElementById('gameOverUI');
const startMainBtn = document.getElementById('startMainBtn'), playAgainBtn = document.getElementById('playAgainBtn'), goHomeBtn = document.getElementById('goHomeBtn');
const scoreLabel = document.getElementById('scoreNum'), enemyScoreLabel = document.getElementById('enemyScore');

// Game Over UI placeholders
const finalScoreEl = document.getElementById('finalScore'), finalHighEl = document.getElementById('finalHigh');
const finalEnemyScoreEl = document.getElementById('finalEnemyScore');
const opponentResultBox = document.getElementById('opponentResultBox');
const opponentFinalScoreEl = document.getElementById('opponentFinalScore');
const opponentFinalEnemyScoreEl = document.getElementById('opponentFinalEnemyScore');
const winnerMessageEl = document.getElementById('winnerMessage');
const waitingMessageEl = document.getElementById('waitingMessage');

// Debug UI
const debugPanel = document.getElementById('debugPanel');
const debugGO = document.getElementById('debugGO');
const debugPending = document.getElementById('debugPending');
const debugOppAlive = document.getElementById('debugOppAlive');
const debugOppConnected = document.getElementById('debugOppConnected');


// New UI elements for joining room
const mainMenuButtons = document.getElementById('mainMenuButtons');
const joinRoomContainer = document.getElementById('joinRoomContainer');
const roomCodeInput = document.getElementById('roomCodeInput');
const submitJoinBtn = document.getElementById('submitJoinBtn');
const cancelJoinBtn = document.getElementById('cancelJoinBtn');

let dpr = Math.max(1, window.devicePixelRatio || 1);

const sndScore = new Audio("point.mp3");
const sndHit = new Audio("darshan.mp3");
const sndFlap = new Audio("flap.mp3");
const sndHitPipe = new Audio("hit.mp3");
let audioUnlocked = true; 

let gameStarted=false, gameOver=false;
let waitingForFirstFlap = false;
let GRAVITY=0.45, JUMP=-8.5;
let bird={x:80,y:300,w:40,h:32,vy:0,rot:0,flapTimer:0};
let pipes=[], enemies=[], frame=0, score=0, enemyScore=0;
let framesSinceLastPipe=0;
let nextPipeIn=100;
let highScore=parseInt(localStorage.getItem('flappy_high')||'0',10);
homeHighScoreNum.textContent=highScore;

function resize(){
    const padding = Math.min(window.innerWidth,24);
    const maxW = window.innerWidth - padding;
    const maxH = window.innerHeight - 80;
    const targetRatio = internalW/internalH;
    let cssW = maxW, cssH=Math.round(cssW/targetRatio);
    if(cssH>maxH){ cssH=maxH; cssW=Math.round(cssH*targetRatio);}
    canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
    dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = internalW*dpr; canvas.height = internalH*dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);

const cloudsA=[], cloudsB=[];
function spawnClouds(){
    for(let i=0;i<6;i++) cloudsA.push({x:Math.random()*internalW,y:Math.random()*140,w:60+Math.random()*80,speed:0.2+Math.random()*0.3,alpha:0.12+Math.random()*0.15});
    for(let i=0;i<4;i++) cloudsB.push({x:Math.random()*internalW,y:160+Math.random()*120,w:80+Math.random()*140,speed:0.35+Math.random()*0.4,alpha:0.06+Math.random()*0.08});
}
spawnClouds();

function generatePipe(){
    const gap = 150;
    const topH=Math.random()*(internalH-gap-160)+50;
    const bottomH=internalH-topH-gap;
    const pipe={x:internalW+10, top:topH, bottom:bottomH, passed:false, w:50};
    pipes.push(pipe);

    const enemyChance = Math.random();
    if(enemyChance < 0.7){
        const enemyY=Math.random()<0.5 ? topH+10 : internalH-bottomH-24-10;
        const isGolden = Math.random()<0.1; // 10% chance
        enemies.push({x:pipe.x+10,y:enemyY,w:32,h:24,speed:3+Math.random()*1,verticalAmp:12+Math.random()*8,verticalFreq:0.05+Math.random()*0.05, golden:isGolden});
    }

    const cssWidth=parseInt(canvas.style.width||internalW,10);
    const base = cssWidth<=360?140:100;
    nextPipeIn = base+Math.floor(Math.random()*30);
    framesSinceLastPipe=0;
}

function resetGame(){
    gameStarted=false; gameOver=false; pipes=[]; enemies=[]; frame=0; score=0; enemyScore=0;
    waitingForFirstFlap = false;
    pendingGameOver = false; // Reset the waiting flag
    
    // IMPORTANT: Ensure bird position is reset before showing the menu
    bird.x=80; bird.y=internalH/2; bird.vy=0; bird.rot=0; bird.flapTimer=0; 
    
    startUI.style.display='flex'; gameOverUI.style.display='none'; scoreLabel.parentElement.style.display='';
    enemyScoreLabel.textContent = enemyScore;
    
    // Reset multiplayer state in UI
    roomCode = null;
    isOwner = false;
    // Set opponent's initial X position off-screen
    opponent = {connected:false, x:-100, y:300, w:40, h:32, rot:0, score:0, enemyScore:0, alive:true};
    roomDisplay.textContent = '';
    startMainBtn.disabled = false;
    winnerMessageEl.style.display = 'none';
    opponentResultBox.style.display = 'none';
    waitingMessageEl.style.display = 'none';
    
    // ⭐ FIX: Ensure Play Again is re-enabled on reset, it will be disabled again 
    // in startGame() for MP games. This fixes local game restarts.
    playAgainBtn.disabled = false; 
    
    // Hide debug panel when returning to main menu
    debugPanel.style.display = 'none';

    // Ensure UI is back to main menu buttons
    mainMenuButtons.style.display = 'flex';
    joinRoomContainer.style.display = 'none';
    roomCodeInput.value = '';

    // If socket is open, make sure we stop any state sending
    stopSendingState();
}

function startGame(){
    gameStarted = true;
    gameOver = false;
    waitingForFirstFlap = true;
    pendingGameOver = false;

    startUI.style.display = 'none';
    gameOverUI.style.display = 'none';
    scoreLabel.parentElement.style.display = '';

    pipes = [];
    enemies = [];
    frame = 0;
    score = 0;
    enemyScore = 0;
    scoreLabel.textContent = score;
    enemyScoreLabel.textContent = enemyScore;
    
    // Disable Play Again until death is handled, specifically for MP mode.
    // If not in a room, it remains enabled in resetGame().
    if(roomCode) {
        playAgainBtn.disabled = true; 
    }


    bird.y = internalH/2;
    bird.vy = 0;
    bird.rot = 0;
    framesSinceLastPipe = 0;
    
    // Reset opponent's status for the new round
    opponent.alive = true; 
    opponent.score = 0; // Reset opponent's score for new round
    
    // Multiplayer Hook: Start sending state if in a room
    if(socket && socket.readyState === WebSocket.OPEN && roomCode){
        opponent.connected = true; 
        startSendingState();
        // The panel is made visible on 'open'. Re-enforce it here.
        debugPanel.style.display = 'block'; 
    } else {
        // Single Player Mode - No roomCode
        debugPanel.style.display = 'none';
        // The playAgainBtn is already enabled from resetGame for local mode
    }
}

function flap(){
    // FIX: Prevent accidental start of a local game (by a click/space) 
    // when the player is in an MP lobby waiting for the owner/opponent.
    if(!gameStarted) {
        if (roomCode) {
            // If in a room, prevent local start on click/space
            roomDisplay.textContent = isOwner ? 'Waiting for opponent to join ' + roomCode : 'Waiting for owner to start the game...';
            return;
        } else {
            // No roomCode, proceed with local start.
            startGame();
        }
    }

    if(waitingForFirstFlap) waitingForFirstFlap = false;

    if(!gameOver && gameStarted){
        bird.vy = JUMP;
        bird.flapTimer=6;
        if(audioUnlocked){ sndFlap.currentTime = 0; sndFlap.play().catch(()=>{}); }
    }
    // Only allow restart in local game mode
    if(gameOver && !roomCode) startGame(); 
}

document.addEventListener('keydown', e=>{if(e.code==='Space'||e.key===' '){e.preventDefault(); flap();}});
canvas.addEventListener('pointerdown', e=>{e.preventDefault(); flap();},{passive:false});

let pendingGameOver = false; // true if we died but waiting for opponent to finish

// Function to handle the final display of scores and winner
function finalizeMultiplayerResults() {
    opponentResultBox.style.display = 'block';
    opponentFinalScoreEl.textContent = opponent.score;
    opponentFinalEnemyScoreEl.textContent = opponent.enemyScore;
    waitingMessageEl.style.display = 'none';
    
    // Determine Winner based on pipe score
    winnerMessageEl.style.display = 'block';
    if (score > opponent.score) {
        winnerMessageEl.textContent = "YOU WIN! (Score: " + score + " vs " + opponent.score + ")";
    } else if (score < opponent.score) {
        winnerMessageEl.textContent = "OPPONENT WINS! (Score: " + opponent.score + " vs " + score + ")";
    } else {
        winnerMessageEl.textContent = "IT'S A TIE! (Score: " + score + ")";
    }
    
    // Enable Play Again button after results are displayed
    playAgainBtn.disabled = false;
    
    // Ensure Game Over UI is visible (in case it was just showing the waiting screen)
    gameOverUI.style.display='flex';
}

function showGameOver(){
    if(gameOver) return; // Prevent double-triggering
    gameOver=true; 
    gameStarted=false;
    
    // FIX: Play the crash sounds immediately when the local player dies.
    try{
        if(audioUnlocked){ sndHitPipe.currentTime=0; sndHitPipe.play().catch(()=>{}); }
        sndHit.currentTime=0; sndHit.play();
    }catch(e){}
    
    // Check if we are in an active room
    const inActiveRoom = socket && socket.readyState === WebSocket.OPEN && roomCode;

    // 1. Update High Score (Local Player)
    if(score>highScore){highScore=score; localStorage.setItem('flappy_high',highScore);}

    // 2. Set Local Player Results
    finalScoreEl.textContent = score;
    finalHighEl.textContent = highScore;
    finalEnemyScoreEl.textContent = enemyScore;
    
    // 3. Handle Multiplayer Logic
    if(inActiveRoom){
        console.log(`[MP DEBUG] Local Player died. Opponent connected: ${opponent.connected}, Opponent alive status: ${opponent.alive}`); 
        
        stopSendingState();
        playAgainBtn.disabled = true; // Disable until final result is known

        // Send final state (alive=false) to server
        try{
            socket.send(JSON.stringify({
                type:'playerUpdate',
                state:{alive:false, score:score, enemyScore:enemyScore, x:bird.x, y:bird.y, rot:bird.rot},
                code:roomCode
            }));
        }catch(e){}

        // FINAL FIX: Check opponent.alive. We MUST wait if the opponent is still flying.
        if(opponent.alive){
            pendingGameOver = true;
            gameOverUI.style.display='flex';
            scoreLabel.parentElement.style.display='none';
            waitingMessageEl.style.display = 'block'; // SHOW THE WAITING MESSAGE
            winnerMessageEl.style.display = 'none';
            opponentResultBox.style.display = 'none';
            return; // Exit here, wait for opponentUpdate
        } else {
             // Opponent is dead or was never connected, finalize immediately.
             if (!opponent.connected) {
                 opponent.score = 0;
                 opponent.enemyScore = 0;
             }
             finalizeMultiplayerResults();
        }
    } else {
        // Single Player Mode - finalize immediately
        opponentResultBox.style.display = 'none';
        winnerMessageEl.style.display = 'none';
        playAgainBtn.disabled = false;
    }
    
    // 4. Show the Game Over UI (if not waiting in MP)
    if(!pendingGameOver){
        gameOverUI.style.display='flex';
        scoreLabel.parentElement.style.display='none';
    }
}
// ---------- UPDATE FUNCTION ----------
function update(dt){
    frame++;

    // Update debug panel state
    if(roomCode) {
        debugGO.textContent = gameOver;
        debugPending.textContent = pendingGameOver;
        debugOppAlive.textContent = opponent.alive;
        debugOppConnected.textContent = opponent.connected;
    }


    cloudsA.forEach(c=>{c.x-=c.speed*dt;if(c.x<-200)c.x=internalW+200;});
    cloudsB.forEach(c=>{c.x-=c.speed*dt;if(c.x<-300)c.x=internalW+300;});

    if(!gameStarted || gameOver || waitingForFirstFlap){
        // In menu/game over, make the bird gently float up and down
        bird.flapTimer=Math.max(0,bird.flapTimer-dt);
        // Corrected calculation for floating animation based on frame
        const floatSpeed = 0.012; // Slower floating
        const floatAmplitude = 1.2;
        bird.vy = Math.sin(frame * floatSpeed) * floatAmplitude;
        bird.y += bird.vy * dt;
        bird.rot = Math.sin(frame * floatSpeed * 0.8) * 0.25; // Slight rotation
        return;
    }

    // Game is active
    bird.vy+=GRAVITY*dt; bird.y+=bird.vy*dt; bird.rot=Math.max(-0.6,Math.min(0.9,bird.vy*0.06));

    framesSinceLastPipe++;
    if(framesSinceLastPipe>=nextPipeIn) generatePipe();

    for(let i=pipes.length-1;i>=0;i--){
        const p=pipes[i]; p.x-=2.6*dt;
        if(!p.passed && p.x+p.w<bird.x){
            p.passed=true; score++; scoreLabel.textContent=score;
            if(audioUnlocked){ sndScore.currentTime=0; sndScore.play().catch(()=>{}); }
        }
        if(p.x<-80)pipes.splice(i,1);
    }

    for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i]; 
        e.x-=e.speed*dt; 
        e.y+=Math.sin(frame*e.verticalFreq+i)*e.verticalAmp*dt*0.1;

        if(bird.x<e.x+e.w && bird.x+bird.w>e.x && bird.y<e.y+e.h && bird.y+bird.h>e.y){
            // ⭐ Increase enemy points and remove enemy (Hit Points)
            enemyScore += e.golden ? 50 : 10;
            enemyScoreLabel.textContent = enemyScore;
            enemies.splice(i,1);
            continue;
        }

        if(e.x<-80) enemies.splice(i,1);
    }
    
    // Do collision checks only if we are still alive
    if (!gameOver) {
        for(const p of pipes){
            if(bird.x<p.x+p.w && bird.x+bird.w>p.x){
                if(bird.y<p.top||bird.y+bird.h>internalH-p.bottom){
                    showGameOver();
                    return; // Exit update loop immediately after dying
                }
            }
        }

        if(bird.y+bird.h>=internalH || bird.y<=0){
            showGameOver();
        }
    }
}

// -------------------- DRAW FUNCTIONS -----------------------
function drawBird(cx,cy,w,h,rot){
    ctx.save(); ctx.translate(cx,cy); ctx.rotate(rot);
    ctx.beginPath(); ctx.ellipse(0,0,w*0.45,h*0.5,0,0,Math.PI*2); ctx.fillStyle='#ffd54a'; ctx.fill();
    ctx.beginPath(); ctx.ellipse(-w*0.05,0,w*0.35,h*0.35,0,0,Math.PI*2); ctx.fillStyle='#fff0d6'; ctx.fill();
    ctx.beginPath(); ctx.ellipse(-w*0.02,h*0.05,w*0.25,h*0.12,-0.6,0,Math.PI*2); ctx.fillStyle='#ffb733'; ctx.fill();
    ctx.beginPath(); ctx.arc(w*0.18,-h*0.08,w*0.07,0,Math.PI*2); ctx.fillStyle='#000'; ctx.fill();
    ctx.beginPath(); ctx.moveTo(w*0.36,0); ctx.lineTo(w*0.58,-h*0.08); ctx.lineTo(w*0.58,h*0.08); ctx.closePath(); ctx.fillStyle='#f39c12'; ctx.fill();
    ctx.restore();
}

// Enemy draw function
function drawEnemy(e){
    ctx.save();
    ctx.translate(e.x + e.w * 0.5, e.y + e.h * 0.5);
    ctx.scale(-1, 1);
    ctx.rotate(Math.sin((e.x + e.y) * 0.01) * 0.1);
    const scale = 0.75;
    const flap = Math.sin(frame * 0.3 + e.x*0.05) * 0.4;
    ctx.beginPath();
    ctx.ellipse(0, 0, (bird.w * 0.45) * scale, (bird.h * 0.5) * scale, 0, 0, Math.PI*2);
    ctx.fillStyle = e.golden ? '#ffd700' : '#ff0000';
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(-bird.w*0.05*scale, 0, bird.w*0.35*scale, bird.h*0.35*scale, 0, 0, Math.PI*2);
    ctx.fillStyle = e.golden ? '#fff8dc' : '#ff6666';
    ctx.fill();
    ctx.save();
    ctx.translate(-bird.w*0.02*scale, bird.h*0.05*scale);
    ctx.rotate(flap);
    ctx.beginPath();
    ctx.ellipse(0, 0, bird.w*0.25*scale, bird.h*0.12*scale, -0.6, 0, Math.PI*2);
    ctx.fillStyle = e.golden ? '#ffdd33' : '#cc0000';
    ctx.fill();
    ctx.restore();
    ctx.beginPath();
    ctx.arc(bird.w*0.18*scale, -bird.h*0.08*scale, bird.w*0.07*scale, 0, Math.PI*2);
    ctx.fillStyle = '#000';
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(bird.w*0.36*scale,0);
    ctx.lineTo(bird.w*0.58*scale,-bird.h*0.08*scale);
    ctx.lineTo(bird.w*0.58*scale,bird.h*0.08*scale);
    ctx.closePath();
    ctx.fillStyle = e.golden ? '#ffcc00' : '#ff9900';
    ctx.fill();
    ctx.restore();
}

function drawCloud(x,y,w){
    ctx.fillStyle='rgba(255,255,255,0.85)';
    ctx.beginPath(); ctx.ellipse(x,y,w*0.7,w*0.4,0,0,Math.PI*2);
    ctx.ellipse(x+w*0.35,y+6,w*0.5,w*0.3,0,0,Math.PI*2);
    ctx.ellipse(x-w*0.35,y+6,w*0.5,w*0.3,0,0,Math.PI*2);
    ctx.fill();
}

function drawPipe(x,y,w,h,isTop){
    const grad=ctx.createLinearGradient(x,y,x,y+h);
    grad.addColorStop(0,'#0a6b3a'); grad.addColorStop(1,'#0a8d4a');
    ctx.fillStyle=grad; ctx.fillRect(x,y,w,h);
    ctx.fillStyle='#8be6a4';
    const rimH=8;
    if(isTop) ctx.fillRect(x-2,y+h-rimH,w+4,rimH);
    else ctx.fillRect(x-2,y-rimH,w+4,rimH);
    ctx.fillStyle='rgba(0,0,0,0.12)';
    ctx.fillRect(x+w-8,y+4,8,h-8);
}

function draw(){
    const g=ctx.createLinearGradient(0,0,0,internalH);
    g.addColorStop(0,'#70c5ce');
    g.addColorStop(1,'#4fb0c8');
    ctx.fillStyle=g; ctx.fillRect(0,0,internalW,internalH);

    cloudsA.forEach(c=>{ctx.globalAlpha=c.alpha; drawCloud(c.x,c.y,c.w);});
    cloudsB.forEach(c=>{ctx.globalAlpha=c.alpha*0.9; drawCloud(c.x,c.y,c.w*1.4);});
    ctx.globalAlpha=1;

    ctx.fillStyle='#2d6b7a'; ctx.fillRect(0,internalH-32,internalW,32);

    for(const p of pipes) drawPipe(p.x,0,p.w,p.top,true), drawPipe(p.x,internalH-p.bottom,p.w,p.bottom,false);
    for(const e of enemies) drawEnemy(e);

    ctx.save(); ctx.translate(bird.x+bird.w*0.5,bird.y+bird.h*0.5); ctx.rotate(bird.rot);
    ctx.globalAlpha=0.12;
    ctx.beginPath(); ctx.ellipse(0,36,bird.w*0.7,8,0,0,Math.PI*2); ctx.fillStyle='#000'; ctx.fill();
    ctx.globalAlpha=1; ctx.restore();

    drawBird(bird.x+bird.w*0.5,bird.y+bird.h*0.5,bird.w,bird.h,bird.rot);
}

/* -------------------------
    Multiplayer client code (hooks + safe checks)
    ------------------------- */

// Opponent object to render other player's bird and stats
// Set initial X position off-screen
let opponent = {connected:false, x:-100, y:300, w:40, h:32, rot:0, score:0, enemyScore:0, alive:true};

// UI elements for multiplayer status & room display
const mpStatusEl = document.getElementById('mpStatus');
const mpPanel = document.getElementById('multiplayerStatus');
const roomDisplay = document.getElementById('roomCodeDisplay');

const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
const serverUrl = 'wss://flappymulti.onrender.com';
let socket = null;
let roomCode = null;
let isOwner = false;
let sendIntervalId = null;

// safe wrapper to create a socket and attach handlers
function connectSocket(){
    try{
        // Use the public WSS URL for production, or localhost for local testing
        const connectionURL = isLocalhost ? "ws://localhost:8080" : serverUrl;
        
        socket = new WebSocket(connectionURL); 
        console.log(`Attempting connection to: ${connectionURL}`); // Add this log to confirm
        
    }catch(e){
        socket = null;
        console.warn('WebSocket construct failed', e);
        roomDisplay.textContent = 'Connection failed. Server unavailable.';
        return;
    }

    socket.addEventListener('open', ()=>{
        console.log('Connected to WebSocket server');
        mpPanel.style.display = 'block';
        mpStatusEl.textContent = 'connected';
        // ⭐ FIX APPLIED HERE: Show debug panel immediately upon successful WebSocket connection
        debugPanel.style.display = 'block'; 
    });

    socket.addEventListener('message', (ev)=>{
        let data;
        try{ data = JSON.parse(ev.data); }catch(e){ return; }

        // handle server messages
       if(data.type === 'roomCreated'){
            roomCode = data.code;
            isOwner = true;
            // When the room is created, the OPPONENT is not connected yet, but the debug panel needs to be initialized.
            opponent.connected = false; 
            opponent.alive = true;
            roomDisplay.textContent = 'Room Code: ' + roomCode;
            // The panel is already visible from the 'open' handler, but we keep this as redundancy.
            debugPanel.style.display = 'block'; 
            mainMenuButtons.style.display = 'flex';
        }

        if(data.type === 'playerJoined'){
            opponent.connected = true;
            opponent.alive = true; // Opponent is guaranteed alive when they first join
            roomDisplay.textContent = 'Room: ' + data.code + ' (Opponent ready)';
            startMainBtn.disabled = false;
        }

        if(data.type === 'startGame'){
            // Server instructs to start the game
            startUI.style.display = 'none';
            // Reset the opponent's 'alive' status for the new round
            opponent.alive = true; 
            startGame();
        }

        if(data.type === 'roomJoined'){
            roomCode = data.code;
            opponent.connected = true; 
            opponent.alive = true;
            roomDisplay.textContent = 'Room: ' + roomCode + ' (Waiting for owner to start)';
            startMainBtn.disabled = true;
            
            // The panel is already visible from the 'open' handler, but we keep this as redundancy.
            debugPanel.style.display = 'block'; 

            mainMenuButtons.style.display = 'flex';
            joinRoomContainer.style.display = 'none';
            roomCodeInput.value = '';
        }
        if(data.type === 'opponentUpdate'){
            const s = data.state || {};
            opponent.connected = true;
            
            // 1. Update opponent's state
            opponent.x = (typeof s.x === 'number') ? s.x : opponent.x;
            opponent.y = (typeof s.y === 'number') ? s.y : opponent.y;
            opponent.rot = (typeof s.rot === 'number') ? s.rot : opponent.rot;
            opponent.score = (typeof s.score === 'number') ? s.score : opponent.score;
            opponent.enemyScore = (typeof s.enemyScore === 'number') ? s.enemyScore : opponent.enemyScore;
            
            const wasAlive = opponent.alive;
            opponent.alive = (typeof s.alive === 'boolean') ? s.alive : opponent.alive;
            
            console.log(`[MP DEBUG] Received Opponent Update. Alive: ${opponent.alive}, Connected: ${opponent.connected}, Score: ${opponent.score}`);

            // 2. Synchronization Check: Did the opponent just die?
            if (gameOver && pendingGameOver && !opponent.alive) {
                // We were waiting (pendingGameOver=true) and the opponent's dead status just arrived
                pendingGameOver = false;
                finalizeMultiplayerResults();
            }
            
            // 3. Inform the player if the opponent died first
            if (!gameOver && wasAlive && !opponent.alive) {
                roomDisplay.textContent = 'Opponent has crashed! Finish the race!';
            }
        }

        if(data.type === 'opponentLeft'){
            opponent.connected = false;
            opponent.alive = false;
            roomDisplay.textContent = 'Room: ' + (roomCode || '') + ' (Opponent disconnected)';
            
            // If the opponent leaves while we are waiting, finalize results immediately
            if(pendingGameOver){
                pendingGameOver = false;
                // Set opponent's score to 0 since they disconnected early.
                opponent.score = 0; 
                opponent.enemyScore = 0;
                finalizeMultiplayerResults();
            }
            
            // If the local player is still in the main menu after room creation/join, 
            // and the opponent leaves, re-enable the Start button if they are the owner.
            if (!gameStarted && !gameOver && isOwner) {
                startMainBtn.disabled = false;
            }
        }

        if(data.type === 'error'){
            console.error('Server Error: ', data.message);
            roomDisplay.textContent = 'Error: ' + (data.message||'Unknown');
            mainMenuButtons.style.display = 'flex';
            joinRoomContainer.style.display = 'none';
            roomCodeInput.value = '';
            // Clear roomCode on error from server
            roomCode = null;
        }
    });

    socket.addEventListener('close', ()=>{
        console.log('Socket closed');
        mpStatusEl.textContent = 'disconnected';
        opponent.connected = false;
        debugPanel.style.display = 'none';
        
        // ⭐ FINAL DIAGNOSTIC FIX: Better feedback for immediate connection loss
        // Check if we were actively waiting for a room confirmation
        if (roomDisplay.textContent.startsWith('Attempting to join room') || roomDisplay.textContent.startsWith('Room Code:')) {
            roomDisplay.textContent = 'Connection failed. Possible causes: Room not found, server unreachable, or join error. Try again.';
        } else if (roomCode) {
            // Active game loss (less likely for this error, but for completeness)
            roomDisplay.textContent = 'Active game connection lost. Try Main Menu.';
        } else {
            roomDisplay.textContent = 'Connection closed.';
        }
        
        roomCode = null; // Ensure roomCode is reset on any socket close
        
        if(sendIntervalId) { clearInterval(sendIntervalId); sendIntervalId = null; }
    });

    socket.addEventListener('error', (e)=>{
        console.warn('Socket error', e);
        mpStatusEl.textContent = 'error';
        debugPanel.style.display = 'none';
        roomDisplay.textContent = 'A critical connection error occurred.';
        roomCode = null;
    });
}

// send our state to server (throttle to ~10 times/sec)
function startSendingState(){
    if(!socket || socket.readyState !== WebSocket.OPEN) return;
    if(sendIntervalId) clearInterval(sendIntervalId);
    sendIntervalId = setInterval(()=>{
        if(!socket || socket.readyState !== WebSocket.OPEN) return;
        const state = {
            type: 'playerUpdate',
            state: {
                x: bird.x,
                y: bird.y,
                rot: bird.rot,
                score: score,
                enemyScore: enemyScore, 
                alive: !gameOver 
            },
            code: roomCode || null
        };
        try{ socket.send(JSON.stringify(state)); }catch(e){}
    }, 100); // 100ms
}

// Stop sending (cleanup)
function stopSendingState(){
    if(sendIntervalId) { clearInterval(sendIntervalId); sendIntervalId = null; }
}

// create room button
document.getElementById('createRoomBtn').addEventListener('click', ()=>{
    if(!socket || socket.readyState !== WebSocket.OPEN){
        connectSocket();
        socket.addEventListener('open', ()=>{
            if(socket && socket.readyState === WebSocket.OPEN) {
                try{ socket.send(JSON.stringify({type:'createRoom'})); }catch(e){}
            }
        }, {once:true});
    }else{
        try{ socket.send(JSON.stringify({type:'createRoom'})); }catch(e){}
    }
});

// Join Room Button (Toggles UI)
document.getElementById('joinRoomBtn').addEventListener('click', ()=>{
    mainMenuButtons.style.display = 'none';
    joinRoomContainer.style.display = 'flex';
    roomCodeInput.focus();
    roomCodeInput.value = ''; 
});

// Submit Join Button (Sends Request)
submitJoinBtn.addEventListener('click', ()=>{
    const code = roomCodeInput.value.trim().toUpperCase();
    if (code.length < 4) {
        roomDisplay.textContent = 'Please enter a 4-character code.';
        return;
    }
    
    roomDisplay.textContent = 'Attempting to join room ' + code + '...';

    const sendJoinRequest = (joinCode) => {
        try {
            socket.send(JSON.stringify({ type: 'joinRoom', code: joinCode }));
        } catch(e) {
            console.error("Error sending join request:", e);
            roomDisplay.textContent = 'Error sending request. Try again.';
        }
    };

    if(!socket || socket.readyState !== WebSocket.OPEN){
        connectSocket();
        socket.addEventListener('open', ()=>{
            if(socket && socket.readyState === WebSocket.OPEN) {
                sendJoinRequest(code);
            }
        }, {once:true});
    } else {
        sendJoinRequest(code);
    }
});

// Cancel Join Button (Hides Input)
cancelJoinBtn.addEventListener('click', ()=>{
    mainMenuButtons.style.display = 'flex';
    joinRoomContainer.style.display = 'none';
    roomCodeInput.value = '';
    roomDisplay.textContent = '';
});


// start button override for multiplayer
startMainBtn.addEventListener('click', (e)=>{
    // If not in a room, start local game immediately
    if(!socket || socket.readyState !== WebSocket.OPEN || !roomCode || !opponent.connected) {
        if(roomCode && !opponent.connected){
            roomDisplay.textContent = 'Waiting for opponent to join ' + roomCode;
            e.preventDefault();
            return;
        }
        startGame();
        return;
    }

    // If in a room, only the owner can trigger the global start
    if(isOwner){
        try{ socket.send(JSON.stringify({type:'startGame', code: roomCode})); }catch(e){}
    } else {
        e.preventDefault();
        roomDisplay.textContent = 'Waiting for owner to start the game...';
    }
});

// Also, when leaving (click Main Menu), tell server we're leaving the room
goHomeBtn.addEventListener('click', ()=>{
    if(socket && socket.readyState === WebSocket.OPEN && roomCode){
        try{ socket.send(JSON.stringify({type:'leaveRoom', code: roomCode})); }catch(e){}
    }
    resetGame();
});

// Play Again button handler - sends request to server to start new round
playAgainBtn.addEventListener('click', ()=>{
    if(roomCode && socket && socket.readyState === WebSocket.OPEN){
        if(isOwner) {
            try{ socket.send(JSON.stringify({type:'startGame', code: roomCode})); }catch(e){}
        } else {
            // Non-owner waits for the owner to start
            gameOverUI.style.display = 'none';
            waitingMessageEl.style.display = 'block';
            waitingMessageEl.textContent = 'Waiting for room owner to start the next round...';
            playAgainBtn.disabled = true;
        }
    } else {
        // Local Game restart
        startGame(); 
    }
});
startMainBtn.addEventListener('click', (e)=>{
    // If not in a room, start local game immediately
    if(!socket || socket.readyState !== WebSocket.OPEN || !roomCode || !opponent.connected) {
        if(roomCode && !opponent.connected){
            roomDisplay.textContent = 'Waiting for opponent to join ' + roomCode;
            e.preventDefault();
            return;
        }
        startGame();
        return;
    }

    // If in a room, only the owner can trigger the global start
    if(isOwner){
        try{ socket.send(JSON.stringify({type:'startGame', code: roomCode})); }catch(e){}
    } else {
        e.preventDefault();
        roomDisplay.textContent = 'Waiting for owner to start the game...';
    }
});

// Also, when leaving (click Main Menu), tell server we're leaving the room
goHomeBtn.addEventListener('click', ()=>{
    if(socket && socket.readyState === WebSocket.OPEN && roomCode){
        try{ socket.send(JSON.stringify({type:'leaveRoom', code: roomCode})); }catch(e){}
    }
    resetGame();
});

// Play Again button handler - sends request to server to start new round
playAgainBtn.addEventListener('click', ()=>{
    if(roomCode && socket && socket.readyState === WebSocket.OPEN){
        if(isOwner) {
            try{ socket.send(JSON.stringify({type:'startGame', code: roomCode})); }catch(e){}
        } else {
            // Non-owner waits for the owner to start
            gameOverUI.style.display = 'none';
            waitingMessageEl.style.display = 'block';
            waitingMessageEl.textContent = 'Waiting for room owner to start the next round...';
            playAgainBtn.disabled = true;
        }
    } else {
        // Local Game restart
        startGame(); 
    }
});

/* -------------------------
    Frame loop + start game initialization (already present earlier)
    ------------------------- */

let lastTime = performance.now();
function frameLoop(time){
    let rawMs = time - lastTime;
    lastTime = time;
    let dt = rawMs / 16.666;
    dt = Math.min(dt, 4);
    update(dt);
    draw();
    requestAnimationFrame(frameLoop);
}
requestAnimationFrame(frameLoop);

resize(); resetGame();
</script>
</body>
</html> 
